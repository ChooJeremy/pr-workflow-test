(()=>{"use strict";var e={};(()=>{e.r=e=>{if(typeof Symbol!=="undefined"&&Symbol.toStringTag){Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}Object.defineProperty(e,"__esModule",{value:true})}})();if(typeof e!=="undefined")e.ab=__dirname+"/";var n={};e.r(n);var t=undefined&&undefined.__awaiter||function(e,n,t,o){function adopt(e){return e instanceof t?e:new t((function(n){n(e)}))}return new(t||(t=Promise))((function(t,i){function fulfilled(e){try{step(o.next(e))}catch(e){i(e)}}function rejected(e){try{step(o["throw"](e))}catch(e){i(e)}}function step(e){e.done?t(e.value):adopt(e.value).then(fulfilled,rejected)}step((o=o.apply(e,n||[])).next())}))};const o=core.getInput("repo-token");const i=github.getOctokit(o);const r=github.context.repo.owner;const s=github.context.repo.repo;const a=github.context.issue.number;const d=github.context.actor;const c=5e3;const u={"Handle PR that may be draft":1,"Handle PR that may be ready for review":1};function wereReviewCommentsAdded(e,n){return t(this,void 0,void 0,(function*(){isValidTimestamp(n);const t=yield i.rest.pulls.listReviewComments({owner:r,repo:s,pull_number:e.number,since:n}).then((e=>{core.info("these comments were retrieved\n"+e);return e})).catch((e=>{throw e}));return t.data.length>0}))}function isValidTimestamp(e){try{Date.parse(e)}catch(e){throw new Error(`the sinceTimeStamp argument passed is an invalid timestamp`)}}function addOngoingLabel(){return t(this,void 0,void 0,(function*(){yield addLabel("s.Ongoing")}))}function addToReviewLabel(){return t(this,void 0,void 0,(function*(){yield addLabel("s.ToReview")}))}function dropOngoingLabelAndAddToReview(){return t(this,void 0,void 0,(function*(){yield removeLabel("s.Ongoing");yield addLabel("s.ToReview")}))}function dropToReviewLabelAndAddOngoing(){return t(this,void 0,void 0,(function*(){yield removeLabel("s.ToReview");yield addLabel("s.Ongoing")}))}function dropOngoingLabel(){return t(this,void 0,void 0,(function*(){yield removeLabel("s.Ongoing")}))}function addLabel(e){return t(this,void 0,void 0,(function*(){yield i.rest.issues.addLabels({owner:r,repo:s,issue_number:a,labels:[e]}).then((n=>l.info(n.status,`added ${e} label with status`))).catch((e=>l.info(e,"error adding label")))}))}function removeLabel(e){return t(this,void 0,void 0,(function*(){yield i.rest.issues.removeLabel({owner:r,repo:s,issue_number:a,name:[e]}).then((e=>logInfo(e.status,`removing label ${e.status} with status`))).catch((e=>logInfo(e,"error removing label (label may not have been applied)")))}))}function sleep(e){return t(this,void 0,void 0,(function*(){core.info(`sleeping for ${e} milliseconds...`);return new Promise((n=>setTimeout(n,e)))}))}const l={info:logInfo,warn:logWarn,jsonInfo:jsonInfo};function logInfo(e,n){core.info(`${n}: ${e}`);return e}function jsonInfo(e,n){core.info(`${n}: ${JSON.stringify(e)}`)}function logWarn(e,n){core.warning(`${n}: ${e}`)}function postComment(e){return t(this,void 0,void 0,(function*(){const n=`Hi ${d}, please note the following. ${e}`;yield i.rest.issues.createComment({owner:r,repo:s,issue_number:a,body:n}).then((e=>core.info(`Commented:\n ${e.data.body}\n with status ${e.status}`))).catch((e=>core.error(e)))}))}function validateChecksOnPrHead(){return t(this,void 0,void 0,(function*(){const e=yield getPRHeadShaForIssueNumber(a);return yield validateChecks(e)}))}function validateChecks(e){return t(this,void 0,void 0,(function*(){core.info(`validating checks on ref: ${e}...`);let n=true;let t;while(n){t=yield i.rest.checks.listForRef({owner:r,repo:s,ref:e});const o=t.data.check_runs;o.forEach((e=>{core.info(`current status for "${e.name}": ${e.status}`)}));const a=o.find((e=>e.status!=="completed"&&!(e.name in u)));if(a!==undefined){yield sleep(c);continue}n=false}const o=t.data.check_runs;let a="";t.data.check_runs.forEach((e=>{if(e.status!=="completed"){a+=`${e.name}'s completion status was ignored because this check is found the excluded checks list\n`}else{a+=`${e.name} has ended with the conclusion: \`${e.conclusion}\`. [Here are the details.](${e.details_url})\n`}}));const d=!o.find((e=>e.conclusion!=="success"&&!(e.name in u)));const f=`There were failing checks found. \n${a}`;l.info(d,"didChecksRunSuccessfully");l.info(a,"conclusions of checks\n");return{didChecksRunSuccessfully:d,errMessage:f}}))}function getPRHeadShaForIssueNumber(e){return t(this,void 0,void 0,(function*(){const n=yield i.rest.pulls.get({owner:r,repo:s,pull_number:e}).catch((e=>{throw e}));const t=n.data.head.sha;l.info(t,"sha");return t}))}var f=undefined&&undefined.__awaiter||function(e,n,t,o){function adopt(e){return e instanceof t?e:new t((function(n){n(e)}))}return new(t||(t=Promise))((function(t,i){function fulfilled(e){try{step(o.next(e))}catch(e){i(e)}}function rejected(e){try{step(o["throw"](e))}catch(e){i(e)}}function step(e){e.done?t(e.value):adopt(e.value).then(fulfilled,rejected)}step((o=o.apply(e,n||[])).next())}))};const h=core.getInput("repo-token");const g=github.getOctokit(h);const p=github.context.repo.owner;const m=github.context.repo.repo;const v=github.context.issue.number;function run(){return f(this,void 0,void 0,(function*(){try{const e=yield isDraftAndNotLabelledOngoing();if(!e){core.info("needs no labelling, ending.");return}yield addOngoingLabel()}catch(e){core.info(e);core.setFailed(e.message)}}))}function isDraftAndNotLabelledOngoing(){return f(this,void 0,void 0,(function*(){return yield g.rest.pulls.get({owner:p,repo:m,pull_number:v}).then((e=>{l.info(e.data.draft,`is pr ${v} draft`);l.info(e.data.labels,"details of existing labels");return e.data.draft&&e.data.labels.find((e=>e.name==="s.Ongoing"))===undefined})).catch((e=>{l.info(e,"error getting pr (issue) that triggered this workflow");throw e}))}))}run();module.exports=n})();