(()=>{"use strict";var e={};(()=>{e.r=e=>{if(typeof Symbol!=="undefined"&&Symbol.toStringTag){Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}Object.defineProperty(e,"__esModule",{value:true})}})();if(typeof e!=="undefined")e.ab=__dirname+"/";var n={};e.r(n);var t=undefined&&undefined.__awaiter||function(e,n,t,o){function adopt(e){return e instanceof t?e:new t((function(n){n(e)}))}return new(t||(t=Promise))((function(t,i){function fulfilled(e){try{step(o.next(e))}catch(e){i(e)}}function rejected(e){try{step(o["throw"](e))}catch(e){i(e)}}function step(e){e.done?t(e.value):adopt(e.value).then(fulfilled,rejected)}step((o=o.apply(e,n||[])).next())}))};const o=core.getInput("repo-token");const i=github.getOctokit(o);const r=github.context.repo.owner;const s=github.context.repo.repo;const a=github.context.issue.number;const c=github.context.actor;const d=5e3;const u={"Handle PR that may be draft":1,"Handle PR that may be ready for review":1};function wereReviewCommentsAdded(e,n){return t(this,void 0,void 0,(function*(){isValidTimestamp(n);const t=yield i.rest.pulls.listReviewComments({owner:r,repo:s,pull_number:e.number,since:n}).then((e=>{core.info("these comments were retrieved\n"+e);return e})).catch((e=>{throw e}));return t.data.length>0}))}function isValidTimestamp(e){try{Date.parse(e)}catch(e){throw new Error(`the sinceTimeStamp argument passed is an invalid timestamp`)}}function addOngoingLabel(){return t(this,void 0,void 0,(function*(){yield addLabel("s.Ongoing")}))}function addToReviewLabel(){return t(this,void 0,void 0,(function*(){yield addLabel("s.ToReview")}))}function dropOngoingLabelAndAddToReview(){return t(this,void 0,void 0,(function*(){yield removeLabel("s.Ongoing");yield addLabel("s.ToReview")}))}function dropToReviewLabelAndAddOngoing(){return t(this,void 0,void 0,(function*(){yield removeLabel("s.ToReview");yield addLabel("s.Ongoing")}))}function dropOngoingLabel(){return t(this,void 0,void 0,(function*(){yield removeLabel("s.Ongoing")}))}function addLabel(e){return t(this,void 0,void 0,(function*(){yield i.rest.issues.addLabels({owner:r,repo:s,issue_number:a,labels:[e]}).then((n=>l.info(n.status,`added ${e} label with status`))).catch((e=>l.info(e,"error adding label")))}))}function removeLabel(e){return t(this,void 0,void 0,(function*(){yield i.rest.issues.removeLabel({owner:r,repo:s,issue_number:a,name:[e]}).then((e=>logInfo(e.status,`removing label ${e.status} with status`))).catch((e=>logInfo(e,"error removing label (label may not have been applied)")))}))}function sleep(e){return t(this,void 0,void 0,(function*(){core.info(`sleeping for ${e} milliseconds...`);return new Promise((n=>setTimeout(n,e)))}))}const l={info:logInfo,warn:logWarn,jsonInfo:jsonInfo};function logInfo(e,n){core.info(`${n}: ${e}`);return e}function jsonInfo(e,n){core.info(`${n}: ${JSON.stringify(e)}`)}function logWarn(e,n){core.warning(`${n}: ${e}`)}function postComment(e){return t(this,void 0,void 0,(function*(){const n=`Hi ${c}, please note the following. ${e}`;yield i.rest.issues.createComment({owner:r,repo:s,issue_number:a,body:n}).then((e=>core.info(`Commented:\n ${e.data.body}\n with status ${e.status}`))).catch((e=>core.error(e)))}))}function validateChecksOnPrHead(){return t(this,void 0,void 0,(function*(){const e=yield getPRHeadShaForIssueNumber(a);return yield validateChecks(e)}))}function validateChecks(e){return t(this,void 0,void 0,(function*(){core.info(`validating checks on ref: ${e}...`);let n=true;let t;while(n){t=yield i.rest.checks.listForRef({owner:r,repo:s,ref:e});const o=t.data.check_runs;o.forEach((e=>{core.info(`current status for "${e.name}": ${e.status}`)}));const a=o.find((e=>e.status!=="completed"&&!(e.name in u)));if(a!==undefined){yield sleep(d);continue}n=false}const o=t.data.check_runs;let a="";t.data.check_runs.forEach((e=>{if(e.status!=="completed"){a+=`${e.name}'s completion status was ignored because this check is found the excluded checks list\n`}else{a+=`${e.name} has ended with the conclusion: \`${e.conclusion}\`. [Here are the details.](${e.details_url})\n`}}));const c=!o.find((e=>e.conclusion!=="success"&&!(e.name in u)));const f=`There were failing checks found. \n${a}`;l.info(c,"didChecksRunSuccessfully");l.info(a,"conclusions of checks\n");return{didChecksRunSuccessfully:c,errMessage:f}}))}function getPRHeadShaForIssueNumber(e){return t(this,void 0,void 0,(function*(){const n=yield i.rest.pulls.get({owner:r,repo:s,pull_number:e}).catch((e=>{throw e}));const t=n.data.head.sha;l.info(t,"sha");return t}))}var f=undefined&&undefined.__awaiter||function(e,n,t,o){function adopt(e){return e instanceof t?e:new t((function(n){n(e)}))}return new(t||(t=Promise))((function(t,i){function fulfilled(e){try{step(o.next(e))}catch(e){i(e)}}function rejected(e){try{step(o["throw"](e))}catch(e){i(e)}}function step(e){e.done?t(e.value):adopt(e.value).then(fulfilled,rejected)}step((o=o.apply(e,n||[])).next())}))};const h=core.getInput("repo-token");const g=github.getOctokit(h);const v=github.context.repo.owner;const b=github.context.repo.repo;const m=github.context.issue.number;const p="Please comment `@bot ready for review` when you've passed all checks, resolved merge conflicts and are ready to request a review.";function run(){return f(this,void 0,void 0,(function*(){l.info(github.context.action,"action");l.info(github.context.payload.action,"payload action");if(!(yield isPRMarkedReadyForReview()))return;const e=yield g.rest.issues.get({owner:v,repo:b,issue_number:m}).then((e=>e.data.labels.map((e=>e.name||e)))).then((e=>l.info(e,`labels returned for pr ${m}`))).catch((e=>{core.info(e);throw e}));const{didChecksRunSuccessfully:n,errMessage:t}=yield validateChecksOnPrHead();if(n){if(hasLabel(e,"s.ToReview")){core.info("already has review label and checks are passing, nothing to be done here. exiting...");return}if(hasLabel(e,"s.Ongoing")&&isOnSynchronise()){core.info("Waiting for user to manually state ready to review. exiting...");return}if(hasLabel(e,"s.Ongoing")){yield dropOngoingLabel()}yield addToReviewLabel()}else{if(hasLabel(e,"s.Ongoing")&&isOnSynchronise()&&(yield wasAuthorLinkedToFailingChecks())){core.info("PR has the ongoing label and author has been notified, exiting...");return}if(hasLabel(e,"s.ToReview")){yield dropToReviewLabelAndAddOngoing()}else if(!hasLabel(e,"s.ToReview")&&!hasLabel(e,"s.Ongoing")){yield addOngoingLabel()}yield postComment(t+"\n"+p)}}))}run();function isOnSynchronise(){l.info(github.context.payload.action,"what triggered this run");return github.context.payload.action==="synchronize"}function hasLabel(e,n){return e.findIndex((e=>e===n))!==-1}function wasAuthorLinkedToFailingChecks(){return f(this,void 0,void 0,(function*(){const sortFn=(e,n)=>{if(!e.created_at||!n.created_at)return 1;return Date.parse(n.created_at)-Date.parse(e.created_at)};const e=yield g.rest.issues.listEvents({owner:v,repo:b,issue_number:m}).then((e=>e.data.sort(sortFn))).catch((e=>{throw e}));const n=e.find((e=>{var n;return e.event==="labeled"&&((n=e.label)===null||n===void 0?void 0:n.name)=="s.Ongoing"}));if(!n){core.warning("Some wrong assumption may have been made or the API used to fetch the PRs may have changed. This function should have been called only on PRs that are assigned the label.");return true}const t=yield g.rest.issues.listComments({owner:v,repo:b,issue_number:m,since:n.created_at}).then((e=>e.data.sort(sortFn))).catch((e=>{throw e}));const o=t.find((e=>e.body.search("There were failing checks found")));l.info(o,"checksFailedComment");return!!o}))}function isPRMarkedReadyForReview(){return f(this,void 0,void 0,(function*(){return yield g.rest.pulls.get({owner:v,repo:b,pull_number:m}).then((e=>{l.info(e.data.draft,`is pr ${m} draft`);return!e.data.draft})).catch((e=>{l.info(e,"Error getting the pr that triggered this workflow");throw e}))}))}module.exports=n})();